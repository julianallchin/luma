The frontend is a React application built with TypeScript that runs inside a Tauri desktop window. The entry point is `main.tsx` which renders the `App` component from `App.tsx`. The app uses Zustand for state management and communicates with the Rust backend through Tauri's invoke API and event listeners.

The main application flow starts in `App.tsx`. This component manages the overall view state using `useAppViewStore` from `features/app/stores/use-app-view-store.ts`. The store tracks the current view type (welcome, pattern editor, track editor) and the currently open project. When no project is open, it shows the `WelcomeScreen` component. Once a project is loaded, it switches to the `ProjectDashboard` which lets you navigate between patterns and tracks.

The pattern editor lives in `features/patterns/components/pattern-editor.tsx`. When you open a pattern, it loads the pattern graph from the backend using `get_pattern_graph`, then renders it in a React Flow-based visual editor. The editor is implemented in `shared/lib/react-flow-editor.tsx` which wraps React Flow and provides an abstraction for node-based graph editing. When you modify the graph, the editor calls `executeGraph` which invokes the `run_graph` command on the backend with a `GraphContext` that provides audio context (track ID, start/end times, beat grid). The backend executes the graph and returns view data (channel outputs, mel spectrograms, series data, colors) which the editor then displays in the various viewer nodes. Playback is managed by the unified host audio system via `features/patterns/stores/use-host-audio-store.ts`, which listens to `host-audio://state` events.

The track editor is in `features/track-editor/components/track-editor.tsx`. It loads track data including waveforms, beat grids, and annotations. The main state lives in `features/track-editor/stores/use-track-editor-store.ts`. When you open a track, it calls `loadTrack` which fetches the beat grid, waveform, and annotations from the backend. The timeline component shows these annotations as colored blocks that represent when patterns should play. You can drag patterns from the pattern registry onto the timeline to create annotations. The track editor uses the same host audio system for playback via `host_load_track`, `host_play`, `host_pause`, and `host_seek` commands.

The project dashboard in `features/app/components/project-dashboard.tsx` shows lists of patterns and tracks. It lets you create new patterns, open existing ones, or import tracks. The welcome screen in `features/app/components/welcome-screen.tsx` shows recent projects and lets you create or open project files.

All communication with the backend happens through Tauri's `invoke()` function from `@tauri-apps/api/core`. The TypeScript types for these commands are generated from the Rust code and live in `bindings/schema.ts`. The backend exposes commands like `list_patterns`, `create_pattern`, `get_pattern_graph`, `save_pattern_graph`, `list_tracks`, `import_track`, `get_track_beats`, and the host audio commands (`host_load_segment`, `host_load_track`, `host_play`, `host_pause`, `host_seek`, `host_set_loop`, `host_snapshot`). The frontend listens to the `host-audio://state` event which broadcasts playback state updates every 50 milliseconds.

The UI uses Tailwind CSS for styling and includes some custom components in `shared/components/ui/` like buttons and other basic UI elements. The app is always in dark mode, which is set in `App.tsx` by adding the "dark" class to the document element.
