The frontend is a React application built with TypeScript that runs inside a Tauri desktop window. The entry point is `main.tsx` which renders the `App` component from `App.tsx`. The app uses Zustand for state management and communicates with the Rust backend through Tauri's invoke API and event listeners.

The main application flow starts in `App.tsx`. This component manages the overall view state using `useAppViewStore` from `features/app/stores/use-app-view-store.ts`. The store tracks the current view type (welcome, pattern editor, track editor) and the currently open project. When no project is open, it shows the `WelcomeScreen` component. Once a project is loaded, it switches to the `ProjectDashboard` which lets you navigate between patterns and tracks.

The pattern editor lives in `features/patterns/components/pattern-editor.tsx`. When you open a pattern, it loads the pattern graph from the backend using `get_pattern_graph`, then renders it in a React Flow-based visual editor. The editor is implemented in `shared/lib/react-flow-editor.tsx` which wraps React Flow and provides an abstraction for node-based graph editing. When you modify the graph, the editor calls `executeGraph` which invokes the `run_graph` command on the backend. The backend executes the graph and returns view data (channel outputs, mel spectrograms, series data, colors) which the editor then displays in the various viewer nodes. The pattern editor also subscribes to playback state events via `listen("pattern-playback://state")` to show real-time playback progress when you play pattern entries. The playback state is managed in `features/patterns/stores/use-pattern-playback-store.ts` which syncs with the backend's playback system.

The track editor is in `features/track-editor/components/track-editor.tsx`. It loads track data including waveforms, beat grids, and annotations. The main state lives in `features/track-editor/stores/use-track-editor-store.ts`. When you open a track, it calls `loadTrack` which fetches the beat grid, waveform, and annotations from the backend. The timeline component shows these annotations as colored blocks that represent when patterns should play. You can drag patterns from the pattern registry onto the timeline to create annotations. The track editor also manages playback by calling `load_track_playback` which loads the audio into the backend's playback system, then uses `playback_play_node`, `playback_pause`, and `playback_seek` commands to control playback. It listens to the same playback state events to keep the playhead position in sync.

The project dashboard in `features/app/components/project-dashboard.tsx` shows lists of patterns and tracks. It lets you create new patterns, open existing ones, or import tracks. The welcome screen in `features/app/components/welcome-screen.tsx` shows recent projects and lets you create or open project files.

All communication with the backend happens through Tauri's `invoke()` function from `@tauri-apps/api/core`. The TypeScript types for these commands are generated from the Rust code and live in `bindings/schema.ts`. The backend exposes commands like `list_patterns`, `create_pattern`, `get_pattern_graph`, `save_pattern_graph`, `list_tracks`, `import_track`, `get_track_beats`, `load_track_playback`, and various playback commands. The frontend also listens to events using `listen()` from `@tauri-apps/api/event`, specifically the `pattern-playback://state` event which broadcasts playback state updates every 50 milliseconds.

The UI uses Tailwind CSS for styling and includes some custom components in `shared/components/ui/` like buttons and other basic UI elements. The app is always in dark mode, which is set in `App.tsx` by adding the "dark" class to the document element.
